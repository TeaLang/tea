---
The builtin libs for Tea

@created 2019/02 by Benny
@copyright YJ Technology Ltd. All rights reserved.
---

public LF = "\n"

// helper functions

public is_uint(val) Bool {
	return is_int(val) and val >= 0
}

public uint_ensure(num Int) {
	if num < 0 {
		throw ErrorException('Cannot use $num as a UInt value')
	}

	return num
}

public is_strict_array(it) Bool {
	if not is_array(it) {
		return false
	}

	if empty(it) {
		return true
	}

	keys = array_keys(it)
	return keys === array_keys(keys)
}

public is_strict_dict(it) Bool {
	if not is_array(it) or empty(it) {
		return false
	}

	if not isset(it[0]) {
		return true
	}

	keys = array_keys(it)
	return keys !== array_keys(keys)
}

public xrange(start Int, end Int, step = 1) {
	i = start
	if step > 0 {
		// step greate than 0, increment
		while i <= end {
			yield i
			i += step
		}
	}
	elseif (step < 0) {
		// step less than 0, decrement
		while i >= end {
			yield i
			i += step
		}
	}
	else {
		throw LogicException('Parameter "step" should not be 0');
	}
}


public _str_replace(master String, search, replacement) {
	return str_replace(search, replacement, master);
}

public _array_search(master Array, search)  {
	key = array_search(search, master, true)
	return key === false ? false : key
}

public array_last_index(array Array) UInt {
	return count(array) - 1
}

public dict_get(dict Dict, key String) {
	return dict[key] ?? none
}

public _dict_search(master Dict, search) {
	key = array_search(search, master, true)
	return key === false ? false : key#String
}

public html_encode(string String?, flags = ENT_QUOTES) {
	return empty(string) ? string : htmlspecialchars(string, flags)
}

public html_decode(string String?, flags = ENT_QUOTES) {
	return empty(string) ? string : htmlspecialchars_decode(string, flags)
}

public regex_test(regex Regex, subject String) Bool {
	return preg_match(regex, subject) ? true : false
}

public regex_capture(regex Regex, subject String) String.Array? {
	var result String.Array
	count = preg_match(regex, subject, result)
	return count === 0 ? none : result
}

public regex_capture_all(regex Regex, subject String) String.Array.Array? {
	var results String.Array.Array
	count = preg_match_all(regex, subject, results)
	return results
}

// 所有 masked function 在定义时都需要考虑参数的顺序，参数的运行时序不一致可能会导致问题
// 考虑禁止在调用函数的参数中改变数据（需要推断出可能改变数据的函数，或直接禁止参数带函数调用），纯表达式?
// 部分实现中，参数编译后顺序有变化，使用时应避免当前字符串被delimiter表达式所改变

// public interface IShareAble {
// 	vshare() Object
// }

// public interface ICloneAble {
// 	vclone() Object
// }

public type MetaType {}
public type UnionType {}

// primitive types

public type Void {} // cannot use for value

public type None {}

// extends String to use the String properties/methods
public type Any: String {}

public type String {
	// process in dist native mode
	masked length UInt => strlen(this)

	masked contains(val) => str_contains(this, val)
	masked find(str String, offset Int = #default) => strpos(this, str, offset)
	masked find_last(str String, offset Int = #default) => strrpos(this, str, offset)
	masked copy(start Int, length Int = #default) => substr(this, start, length)
	masked lower_case() => strtolower(this)
	masked upper_case() => strtoupper(this)

	// process in byte mode
	masked byte_length UInt => strlen(this)
	masked byte_find(str String, offset Int = #default) => strpos(this, str, offset)
	masked byte_find_last(str String, offset Int = #default) => strrpos(this, str, offset)
	masked byte_copy(start Int, length Int = #default) => substr(this, start, length)
	masked byte_lower() => strtolower(this)
	masked byte_upper() => strtoupper(this)

	// process in rune mode
	masked rune_length UInt => iconv_strlen(this)
	masked rune_find(str String, offset Int = #default) => iconv_strpos(this, str, offset)
	masked rune_find_last(str String, offset Int = #default) => iconv_strrpos(this, str, offset)
	masked rune_copy(start Int, length Int = #default) => iconv_substr(this, start, length)
	masked rune_lower() => mb_strtolower(this)
	masked rune_upper() => mb_strtoupper(this)

	// other
	masked count_width() UInt => mb_strwidth(this)
	masked split(delimiter String) => explode(delimiter, this)
	masked replace(search, replacement) => _str_replace(this, search, replacement)
}

public type Int: String {
	masked abs() UInt => abs(this)
}

public type UInt: Int {}

public type Float {
	masked abs() => abs(this)
	masked ceil() => ceil(this)
	masked floor() => floor(this)
	masked round(precision = 0) => round(this, precision)
}

public type Bool {}

public type Array {
	masked length UInt => count(this)
	masked end UInt => array_last_index(this)

	masked has(key Int) => array_key_exists(key, this)
	masked contains(val) => in_array(val, this)

	masked find(val) => _array_search(this, val) // find the index for supported value

	masked copy(start Int, length UInt = #default) Array => array_slice(this, start, length)
	masked reversed() Array => array_reverse(this)

	masked unshift(item) => array_unshift(this, item)
	masked shift() => array_shift(this)
	masked push(item) => array_push(this, item)
	masked pop() => array_pop(this)

	// callback(item)
	masked map(callback Callable) => array_map(callback, this)

	// callback(carry, item)
	masked reduce(callback Callable, initial Any = #default) => array_reduce(this, callback, initial)

	// callback(item) Bool
	masked filter(callback Callable) => array_filter(this, callback)

	masked join(glue String = LF) => implode(glue, this)
}

public type Dict {
	masked length => count(this)

	masked keys() => array_keys(this)
	masked values() => array_values(this)

	masked has(key String) => array_key_exists(key, this)
	masked contains(val) => in_array(val, this)

	masked get(key String) => dict_get(this, key)
	masked find(val) => _dict_search(this, val) // find the key with supported value

	masked join(glue String = LF) => implode(glue, this)
}

public type Object {
	//
}

// primitive types end

public type Regex {
	// match in target string, returns is matched
	masked test(string String) Bool => regex_test(this, string)

	// use this pattern to separate a string, returns the separated items
	masked separate(string String) String.Array => preg_split(this, string)

	// match in target string, returns the first captured item
	masked capture(string String) String.Array => regex_capture(this, string)

	// match in target string, returns the all captured items
	masked capture_all(string String) String.Array.Array => regex_capture_all(this, string)
}

public type XView: String {}   // accept IView

public type Callable {}

public type Iterable {} // accept Iterator

public interface IView {}

// the full Generator haven't supported by yet

// end
